## TCP/IP协议 ##

### TCP/IP协议的由来 ###

各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。让他们无法合作一样。计算机使用者意识到，计算机只是单兵作战并不会发挥太大的作用。只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起.但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。

### TCP/IP 协议分层

##### 分层 #####
- OSI 网络分层分为七层
    - 应用层
    - 表示层
    - 会话层
    - 传输层
    - 网络层
    - 数据链路层
    - 物理层

- TCP/IP由四个层次组成
    - 应用层
    - 传输层(TCP)
    - 网络层(IP)
    - 网络接口层(数据链路层)
  
##### TCP/IP协议族的结构分析 #####
- 分析 
TCP/IP协议簇按照层次由上到下,层层包装。最上面的就是应用层了，这里面有http，ftp,等等我们熟悉的协议。第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是叫数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。再往下则是硬件层次了，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等（这些我们就不用关心了，我们也不做网卡），所以有些书并不把这个层次放在tcp/ip协议族里面，因为它几乎和tcp/ip协议的编写者没有任何的关系。发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构非常有栈的味道，所以也把tcp/ip协议族称为tcp/ip协议栈。

- HTTP的应用图示

    ![](http://i.imgur.com/AntpCc0.jpg)

### 基本知识 ###

- IP地址
    网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。
    **注意**：IP地址是网络号+主机号的组合

- 域名系统（DNS）
    域名系统是一个分布的数据库，它提供主机名（也就是网址）转换成IP地址的服务。

- 端口号
    注意，这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口。比如80(HTTP默认网络端口号)，443（HTTPS默认端口号）我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。
- 应用编程接口
     现在常用的编程接口有socket和TLI。前面的有时候也叫做“Berkeley socket”，可见Berkeley对于网络的发展有多大的贡献。

### UDP协议 ###
##### 介绍 #####
UDP是传输层协议，和TCP协议处于一个分层中，但是与TCP协议不同，UDP协议并不提供超时重传，出错重传等功能，也就是说其是不可靠的协议。
##### UDP协议头 #####
   - UDP端口号
    由于很多软件需要用到UDP协议，所以UDP协议必须通过某个标志用以区分不同的程序所需要的数据包。端口号的功能就在于此，例如某一个UDP程序A在系统中注册了8080端口，那么，以后从外面传进来的目的端口号为8080的UDP包都会交给该程序。端口号理论上可以有2^16 = 65535 这么多。因为它的长度是16个bit
 
   - UDP检验和
     这是一个可选的选项，并不是所有的系统都对UDP数据包加以检验和数据(相对TCP协议的必须来说)，但是RFC中标准要求，发送端应该计算检验和。UDP检验和覆盖UDP协议头和数据，这和IP的检验和是不同的，IP协议的检验和只是覆盖IP数据头，并不覆盖所有的数据。UDP和TCP都包含一个伪首部，这是为了计算检验和而摄制的。伪首部甚至还包含IP地址这样的IP协议里面都有的信息，目的是让UDP两次检查数据是否已经正确到达目的地。如果发送端没有打开检验和选项，而接收端计算检验和有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文。

   - UDP长度
    UDP可以很长很长，可以有65535字节那么长。但是一般网络在传送的时候，一次一般传送不了那么长的协议（涉及到MTU的问题），就只好对数据分片，当然，这些是对UDP等上级协议透明的，UDP不需要关心IP协议层对数据如何分片。

##### IP分片 #####
> IP在从上层接到数据以后，要根据IP地址来判断从那个接口发送数据（通过选路），并进行MTU的查询，如果数据大小超过MTU就进行数据分片。数据的分片是对上层和下层透明，而数据也只是到达目的地还会被重新组装，不过不用担心，IP层提供了足够的信息进行数据的再组装。在IP头里面，16bit识别号唯一记录了一个IP包的ID,具有同一个ID的IP片将会被重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表示中间的3bit标志则标示着该分片后面是否还有新的分片。这三个标示就组成了IP分片的所有信息，接受方就可以利用这些信息对IP数据进行重新组织（就算是后面的分片比前面的分片先到，这些信息也是足够了）。
 

### TCP协议 ###

TCP和UDP处在同一层---运输层，但是TCP和UDP最不同的地方是，TCP提供了一种可靠的数据传输服务，TCP是面向连接的，也就是说，利用TCP通信的两台主机首先要经历一个“拨号”握手的过程，等到通信准备结束才开始传输数据，最后结束通话。所以TCP要比UDP可靠的多，UDP是把数据直接发出去，而不管对方是不是在收信，就算是UDP无法送达，也不会产生ICMP差错报文。

##### TCP保证可靠性工作原理 #####

-  应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的 数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段（ segment）

-  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能 及时收到一个确认，将重发这个报文段。

- 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒
- TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输 过程中的任何变化。如果收到段的检验和有差错， T P将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。

- 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段 的到达也可能会失序。如果必要， TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 

- TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

总结一句话：TCP中保持可靠性的方式就是超时重发，直到对方确认为止。 

##### TCP数据的发送数据过程 #####
    

- 双方建立连接，也就是三次握手建立连接的过程。

- 发送方给接受方TCP数据报，然后等待对方的确认TCP数据报，如果没有，就重新发，如果有，就发送下一个数据报。

- 接受方等待发送方的数据报，如果得到数据报并检验无误，就发送ACK(确认)数据报，并等待下一个TCP数据报的到来。直到接收到FIN(发送完成数据报)

- 中止连接，也就是四次握手释放连接过程

##### 三次握手建立连接过程 #####

- 图示
    ![Socket连接](http://i.imgur.com/nHzyrAq.png)

从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。

过程如下：
- 客户端向服务器发送一个SYN J。
- 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1。
- 客户端再想服务器发一个确认ACK K+1。

##### 四次握手释放连接过程 #####
- 图示
    ![](http://i.imgur.com/AldEPjO.png) 

过程如下：
- 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M。
- 另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据。
- 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N。
- 接收到这个FIN的源发送端TCP对它进行确认。